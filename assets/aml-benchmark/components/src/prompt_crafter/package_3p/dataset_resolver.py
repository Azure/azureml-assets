### WARNING: Do not edit this file directly. It is a clone from azure.ml.babel.dojo.core.utils.dataset_resolver
### Any changes should be made in dojo.core.utils.dataset_resolver directly
import glob
import os
from typing import Optional
import logging

logger = logging.getLogger(__name__)


def resolve_file(input_path: str, filename: Optional[str] = None):
    """Resolve input path as single file from directory.

    Given input path can be either a file, or a directory. If its a file, it
    will be returned. If its a directory with a single file, that will be returned.
    If its a directory with multiple files and filename is provided, it will return
    the unique file matching the filename.

    Args:
        input_path (str): Either file or directory path
        filename (Optional[str]): If provided, will look for this file in dataset,
            assuming its a directory. Supports glob patterns.
    
    Examples:
        # my_dir contains only one file
        >>> resolve_file("my_dir")
        
        # my_dir contains multiple files
        >>> resolve_file("my_dir", "my_file.txt")
        
        # my_dir contains unique .txt file
        >>> resolve_file("my_dir", "*.txt")

    Returns:
        str: path to file
    """
    if os.path.isfile(input_path):
        logger.info(f"Found input file: {input_path}")
        return input_path

    if os.path.isdir(input_path):
        all_files = os.listdir(input_path)

        if not all_files:
            raise RuntimeError(f"Could not find any file in specified input directory {input_path}")

        if len(all_files) == 1:
            logger.info(f"Found input directory {input_path}, selecting unique file {all_files[0]}")
            return os.path.join(input_path, all_files[0])

        elif len(all_files) > 1 and filename is not None:

            logger.info(f"Found input directory {input_path}, selecting unique file {filename}")
            all_files = glob.glob(os.path.join(input_path, filename))
            if len(all_files) == 1:
                return all_files[0]
            else:
                raise RuntimeError(f"Found multiple files in input file path {input_path} for glob pattern {filename}")

        else:
            raise RuntimeError(f"Found multiple files in input file path {input_path}, specify the file name in addition.")

    logger.critical(f"Provided INPUT path {input_path} is neither a directory nor a file.")
    return input_path

def resolve_file_list(input_path: str, filename: Optional[str] = None):
    """Resolve input path as list of files in the directory.

    Given input path can be either a file, or a directory. If it is a file, it
    will be returned as a single item list. If its a directory the list of file(s)
    will be returned.
    If filename is provided, only files with the matching filename format will be returned.

    Args:
        input_path (str): Either file or directory path
        filename (Optional[str]): If provided and input is a dir folder, will look for this
         file format in dataset, assuming its a directory. Supports glob patterns.
    
    Examples:
        # my_dir contains only one file
        >>> resolve_file_list("my_dir")
        
        # my_dir contains .txt file
        >>> resolve_file_list("my_dir", "*.txt")

    Returns:
        list[str]: a list of paths to files
    """
    if os.path.isfile(input_path):
        logger.info(f"Found input file: {input_path}")
        return [input_path]

    if os.path.isdir(input_path):
        all_files = os.listdir(input_path)

        if not all_files:
            raise RuntimeError(f"Could not find any file in specified input directory {input_path}")

        elif filename is not None:

            logger.info(f"Found input directory {input_path}, selecting file(s) {filename}")
            all_files = glob.glob(os.path.join(input_path, filename))
            if len(all_files) >= 1:
                return all_files
            else:
                raise RuntimeError(f"Could not find any file in input file path {input_path} for glob pattern {filename}")
        else:
            return [os.path.join(input_path, file) for file in all_files]

    logger.critical(f"Provided INPUT path {input_path} is neither a directory nor a file.")
    return input_path
